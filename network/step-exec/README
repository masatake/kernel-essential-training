================================================================
カーネルエッセンシャルネットワーク編で用いた実験用プログラム
================================================================

unixソケットの状態を確認するためのプログラム

	* step-server-unix
	* step-client-unix


tcpソケットの状態を確認するためのプログラム

	* step-server-tcp
	* step-client-tcp


ビルド手順
================================================================

gcc、make及びglibc-headersパッケージがインストールされていることを確認
します。

	$ make

とします。

使い方
================================================================

全てのプログラムは引数なしで起動します。
「unixソケットの状態を確認するためのプログラム」は"/tmp/step.sock"を
「tcpソケットの状態を確認するためのプログラム」は127.0.0.1 9999を
待ち受けアドレスとしてbind/connectします。アドレスを変更したい場合
プログラムソースコードを編集してビルドし直して下さい。

全てのプログラムの使い方は共通です。[return]キーを押すと、ソケット通信
をするための一連のシステムコールを一つ一つ呼び出していきます。ただし具
体的なI/O(read/recv, write/send)は何も実行しません。最終的のソケットを
クローズした後、さらに[return]キーを押すと、serverプログラムはacceptを
呼び出すところから、clientプログラムはsocketを作るところから処理を再開
します。[Ctrl-c]あるいは[Ctrl-d]でプロセスは終了します。

プロンプトは
::

	[A->B]> 

という形式をしています。「一連のシステムコール」の何を実行したか(A)、何
を実行しようとしているか(B)を示します。

例::

	[listen->accept]>

これは今listenの呼び出しが完了して、次に[return]キーを押すとacceptを
呼び出すことを意味します。ただし起動直後は何もシステムコールを呼び出して
いないので、::

	[->socket]>

となります。またclientについてはsocketを呼び出し直す前にretryと
表示します。::

	[retry->socket]>

以下の手順で典型的な処理を試すことができます。

1. あるターミナルでserverプログラムを起動してacceptするところまで進める。
   完了しない。
2. 別のターミナルでserverと同じアドレスファミリーを使うclientを起動して
   connectする。
3. serverプログラムのacceptが完了する。

連絡先
================================================================

大和 正武 <yamato@redhat.com>
